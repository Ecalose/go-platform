
目前，ctx在参数中进行传递已是一个很常见的开发习惯，比如gin、echo..等框架都采用这样的方式进行请求上下文传递，我们可以用ctx做超时、并发、链路数据存储等工作。
## 常见的context传递方式
gin示例如下：
```go
package main

import (
  "net/http"

  "github.com/gin-gonic/gin"
)

func main() {
  r := gin.Default()
  r.GET("/ping", func(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{
      "message": "pong",
    })
  })
  r.Run() // listen and serve on 0.0.0.0:8080 (for windows "localhost:8080")
}
```
kratos service示例如下
```go
package service

import (
	"context"
	v1 "kratos-cqrs/api/logger/service/v1"
)

func (s *LoggerService) ListSensorData(ctx context.Context, req *v1.ListSensorDataReq) (*v1.ListSensorDataReply, error) {
	return s.sensorData.List(ctx, req)
}

func (s *LoggerService) GetSensorAvgData(ctx context.Context, req *v1.GetSensorAvgDataReq) (*v1.GetSensorAvgDataReply, error) {
	return s.sensorData.Avg(ctx, req)
}
func (s *LoggerService) GetSensorAvgAndLatestData(ctx context.Context, req *v1.GetSensorAvgAndLatestDataReq) (*v1.GetSensorAvgAndLatestDataReply, error) {
	return s.sensorData.AvgAndLatest(ctx, req)
}

```

## kratos 依赖注入的弊端
在kratos开发过程中，我们通常会在启动的时候把全局的一些中间件通过传递挂载到具体的biz下，但是随着初始化的全局组件越来越多，我们开始使用依赖注入之类的工具来解决，但是这样不仅产生了额外的代码，还降低了代码的可读性。

实际上我们在开发过程中会使用很多的中间件，这些中间件需要不断的暂用额外的参数进行传递，反而增加了参数的数量，使得代码可读性变得极差。
如下示例中使用到了logger和database两个中间件，最终依赖注入代码如下，你可以试想一下，当我们使用再使用redis、再使用mq、在使用...这样参数的传递无限增常，这将变成一个灾难了。
```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"github.com/go-kratos/kratos/v2"
	"github.com/go-kratos/kratos/v2/log"
	"kratos-cqrs/app/logger/job/internal/biz"
	"kratos-cqrs/app/logger/job/internal/conf"
	"kratos-cqrs/app/logger/job/internal/data"
	"kratos-cqrs/app/logger/job/internal/server"
	"kratos-cqrs/app/logger/job/internal/service"
)

// Injectors from wire.go:

// initApp init kratos application.
func initApp(confServer *conf.Server, registry *conf.Registry, confData *conf.Data, logger log.Logger) (*kratos.App, func(), error) {
	client := data.NewEntClient(confData, logger)
	dataData, cleanup, err := data.NewData(client, logger)
	if err != nil {
		return nil, nil, err
	}
	sensorRepo := data.NewSensorRepo(dataData, logger)
	sensorUseCase := biz.NewSensorUseCase(sensorRepo, logger)
	sensorDataRepo := data.NewSensorDataRepo(dataData, logger)
	sensorDataUseCase := biz.NewSensorDataUseCase(sensorDataRepo, logger)
	loggerJobService := service.NewLoggerJobService(sensorUseCase, sensorDataUseCase, logger)
	grpcServer := server.NewGRPCServer(confServer, logger, loggerJobService)
	kafkaServer := server.NewKafkaServer(confServer, logger, loggerJobService)
	registrar := server.NewConsulRegistrar(registry)
	app := newApp(logger, grpcServer, kafkaServer, registrar)
	return app, func() {
		cleanup()
	}, nil
}

```

## kratosx 上下文
上面我们提到依赖注入存在的一些弊端，通过kratosx上下文可以轻松解决这个问题。
ctx上下文既然是本来就需要进行携带传递的，那我们只要能够实现ctx对应的接口，再把常用的一些中间件挂载上去，这样既能减少参数，又能使得ctx保持原有的功能，何乐而不为呢?
kratosx在kratos的基础上进行了进一步的修改，增加了kratosx.Context接口，kratosx.Content继承context.Context的方法，定义如下
```go 
type Context interface {
    Env() string
    Logger() *log.Helper
    DB(name ...string) *gorm.DB
    Transaction(fn func(ctx Context) error, name ...string) error
    Redis(name ...string) *redis.Client
    Go(runner pool.Runner) error
    Loader(name string) []byte
    Email() email.Email
    ClientIP() string
    Captcha() captcha.Captcha
    JWT() jwt.Jwt
    Token() string
    Authentication() authentication.Authentication
    Ctx() context.Context
    GetMetadata(string) string
    SetMetadata(key, value string)
    WaitRunner() pool.WaitRunner
    Http() http.Request
    GrpcConn(srvName string) (*grpc.ClientConn, error)
    
    ID() string
    Name() string
    Version() string
    Metadata() map[string]string
    Config() config.Config
    Endpoint() []string
    
    Clone() Context
    Deadline() (deadline time.Time, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key any) any
}
```
## 快速使用context
直接通过新建ctx使用
```go
c := context.Background()
ctx := kratosx.MustContext(c)

ctx.DB() //使用数据库
ctx.Logger() //使用日志
ctx.Config() //使用配置
ctx.... 
```
在kratos中请求中使用
```go
func (s *TaskService) DeleteTaskGroup(c context.Context, req *pb.DeleteTaskGroupRequest) (*pb.DeleteTaskGroupReply, error) {
	// 变更c=>kratosx.Context，让后续的ctx直接使用kratosx.Context
	err := s.uc.DeleteTaskGroup(kratosx.MustContext(c), req.Id)
	if err != nil {
		return nil, err
	}
	return &pb.DeleteTaskGroupReply{}, nil
}
```

```go
// SayHello implements SayHello
func (l *UseCase) DeleteTaskGroup(ctx kratosx.Context, id uint32) error {
	// 使用日志
	ctx.Logger().Infow("info", "say hello request")
	// ...
	return  nil
}
```

## 项目初始化注入
我们可以直接在项目初始化时注入ctx，以实现一些全局变量的存储等操作。
```go 
package main

import (
	"context"
	"github.com/go-kratos/kratos/v2"
	"github.com/go-kratos/kratos/v2/log"
	"github.com/go-kratos/kratos/v2/transport/grpc"
	"github.com/go-kratos/kratos/v2/transport/http"
	"github.com/limes-cloud/kratosx"
	"github.com/limes-cloud/kratosx/config"
	_ "go.uber.org/automaxprocs"

	"layout/internal/conf"
	"layout/internal/service"
)

func main() {
	ctx := context.Background()
	app := kratosx.New(
		kratosx.RegistrarServer(RegisterServer),
		kratosx.Options(kratos.Context(ctx)),
	)

	if err := app.Run(); err != nil {
		log.Fatal(err.Error())
	}
}

func RegisterServer(c config.Config, hs *http.Server, gs *grpc.Server) {
	cfg := &conf.Config{}
	c.ScanWatch("business", func(value config.Value) {
		if err := value.Scan(cfg); err != nil {
			log.Error("business 配置变更失败")
		} else {
			log.Error("file 配置变更成功")
		}
	})

	service.New(cfg, hs, gs)
}

```
